Скриншоты:
01.jpg - установка пакета pillow последней версии в систему.
02.jpg - Создание и активация виртуального окружения. Отсутствие в нем каких-либо пакетов и пакета pillow в частности.
03.jpg - Установка в виртуальное окружение pillow версии 7.1.1
04.jpg - Деактивация виртуального окружения

Задача на получение курса валют:
Я потренировалась работать с xml, и по идее, функцию можно преобразовать на работу как с json, так и с xml, просто на вход подавать выбранный способ. Этот опыт может пригодиться в случае, когда api разные, форматы разные, а дальнейшая работа с данными одинаковая.

Можно ли, используя только методы класса str, решить поставленную задачу?
Если совсем никаких библиотек не подключать, то нет. Для того, чтобы сделать запрос, нужна библиотека requests.
А вот поработать с ответом библиотеки requests методами строк уже возможно. Я потестировала этот вариант в функции currency_rates_str_only.
По ходу работы методами строки такие размышления:
1) это не очень надежно. Изменят владельцы api название поля и всё, переписывать всё по-новой (и в сравнении с другими методами парсинга вариант со строками - дольше и сложнее)
2) код не очевиден. Через месяц нужно будет приложить усилие и вспомнить, почему написано так. При условии, что решение в общем-то в лоб:
* а) Сначала я ищу код в строке всего ответа. Если его нет, сразу возвращаю None. Если есть, иду дальше
* б) я знаю, что данные нужной мне валюты заключены в тег Valute. И теперь моя задача - выледить подстроку между тегами с нужным мне кодом. Делаю это в два этапа: выделаю начало строки и конец строки.
* в) склеиваю в одну строку с нужными мне данными.
* г) так как здесь уже теги будут уникальны, то ищу по индексу теги value и вычисляю, в каком месте строки находится нужный мне ответ.
* д) преобразовываю, возаращаю ответ
3) XLM очень любят java-разработчики, т.к. там полно инструментов для работы с ним и загрузки целого класса из объектов xml.
В python же ближе, быстрее и понятнее json. Это вечный бой :D


Подумайте: есть ли смысл для работы с денежными величинами использовать вместо float тип Decimal?
Да, есть, т.к. меньше шансов потерять "копейки и полукопейки" и подсчеты прозрачнее.
Сильно ли усложняется код функции при этом?
Нет. Единственное, что при работе с форматом json для точности нужно сначала преобразовать значение в строку, поскольку при выполнении json.loads число автоматом становится float. А при конвертации чисел из float в decimal уже закладывается погрешность:
Decimal(str("59.3299")) -> 59.3299
Decimal.from_float(float("59.3299")) -> 59.32990000000000208046913030557334423065185546875
Насколько я понимаю, имеет смысл сразу работать с decimal, т.е. все операции сложения и деления производить в этом типе уже, тогда не будет таких погрешностей.


Можно ли сделать работу функции не зависящей от того, в каком регистре был передан аргумент?
да, можно. Сделано.