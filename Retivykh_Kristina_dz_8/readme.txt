1) в email-логине может использоваться и английские символы, и цифры, и подчеркивания, и точки.

Задача валидации email адремя вызывает много споров среди программистов. Я как-то столкнулась с ней на практике (работала разработчиком не на python) и поняла, что в каждой компании эта проверка происхожит в зависимости от внутренней договорённости.
По идее, существует стандарт регулярного выражения для валидации  (http://www.ex-parrot.com/~pdw/Mail-RFC822-Address.html), но многие программисты считают самой точной проверкой - выслать код на указанный адрес, а там пусть человек уже подтверждает или не подтверждает его.

Составив свой вариант регулярки, я сверилась с литературой. Авторы книги "Регулярные выражения. Сборник рецептов" выделяют 5 вариантов валидации, начиная от простого (проверить наличие @ и отсутствие пробельных символов в адресе).
Т.к. это зазача на то, чтобы потренироваться, то свой вариант я и оставила.

Существует стандарт регулярки для проверки email адреса, однако я встречала среди программистов мнение, что лучшая проверка - отправить письмо на адрес и получить подтверждение. В книге же написано следующее:
"Этот рецепт представляет собой яркий пример ситуации, когда прежде, чем браться за создание регулярного выражения, необходимо точно решить, что именно требуется проверить. Не существует универсального правила, согласно которому можно было бы однозначно сказать, какой адрес является корректным, а какой - нет. Всё зависит от определения, что считать проавильным.

<...> Поскольку в конечном счете всё равно придется проверять существование адреса, послав на него сообщение, можно ограничиться более простым и менее строгим регулярным выражением. принимать некорректные адреса может оказаться предпочтительнее, чем вызывать недовольство пользователей, отвергая корректные адреса. Учитывая это обстоятельство, можно отдать предпочтение регулярному выражению, «выполняющему простую проверку без ограничения допустимого набора символов»."

3) Примечание: если аргументов несколько - выводить данные о каждом через запятую;
сделано.

можете ли вы вывести тип значения функции?
да, сделала.

Сможете ли решить задачу для именованных аргументов?
да, сделала. Для именованных аргументов не задан точный шаблон вывода, поэтому составила свой. при необходимости легко редактируется к общему виду.

Сможете ли вы замаскировать работу декоратора?
Да. Используя @wraps(func) из модуля functools.

Сможете ли вывести имя функции, например, в виде:
>>> a = calc_cube(5)
calc_cube(5: <class 'int'>)
да, добавила вывод имени функции в декоратор.


Заодно потренировалась в том, чтобы определять внутри python, какая версия используется и уже выбирать реализацию.