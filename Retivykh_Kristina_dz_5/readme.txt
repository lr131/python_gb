Сама по себе тема генераторов сложно далась. Очень похожа на тему указателей и в то же время это другое. Смысл поняла, на практике пока ещё возникает ступор, если решать надо именно генератором.

Предполагаю, что задачу 3 можно было решать через корутины, но пока не хватило времени разобраться с ними. Здесь же сложность, как перехватить исключение StopIteration, так как конструкция
        except StopIteration:
            print("Исключение")
эффекта не дала. Вернусь к этой теме после 7 урока про исключения (ещё не смотрела).

Подумать, в каких ситуациях генератор даст эффект.
 - Вероятно, когда происходит разовая обработка большого объема данных. Ещё предполагаю, что даст эффект при работе с api, если надо один раз "на подлете" отфильтровать данные и потом их не хранить, при интеграции разных систем между собой, для "очистки" данных (по сути, разового парсинга), в сложных вычислениях


В задаче 5 сначала была мысль использовать множество, но по итогу вернулась к идее со списком, только к list comprehensions, так как в условии сказано, что важно сохранить порядок.
List Comprehensions, как правило, работают быстрее, чем код, записанный через цикл for in (из методички).
Для оптимизации памяти, предполагаю, можно было бы возвращать tuple, который при нужде в дальнейшем коде легко конвертировать обратно список.
